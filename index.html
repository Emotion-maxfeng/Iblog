<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/Iblog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/Iblog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/Iblog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/Iblog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/Iblog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/Iblog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/Iblog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="燃烧陨石的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="开源技术  乐于分享">
<meta property="og:url" content="http://Emotion-maxfeng.github.io/Iblog/index.html">
<meta property="og:site_name" content="开源技术  乐于分享">
<meta property="og:description" content="燃烧陨石的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="开源技术  乐于分享">
<meta name="twitter:description" content="燃烧陨石的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/Iblog/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://Emotion-maxfeng.github.io/Iblog/"/>





  <title>开源技术  乐于分享</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/Iblog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">开源技术  乐于分享</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">知识就像一杯苦茶，越苦越有味！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/Iblog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/Iblog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/Iblog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/Iblog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Emotion-maxfeng.github.io/Iblog/Iblog/2017/12/25/Tomcat源码第四篇（手写一个Tomcat）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马雪峰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Iblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开源技术  乐于分享">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Iblog/2017/12/25/Tomcat源码第四篇（手写一个Tomcat）/" itemprop="url">Tomcat源码第四篇（手写一个Tomcat）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-25T16:47:03+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>我们完全可以利用java网络编程实现一个简单的Tomcat，之后在这个简单的编程的基础上进行一系列优化，本人在读取源码的过程中遇到了非常多的问题，最大的问题是找不准切入点，那么我们如果有编程模型的话，切入点是非常好找的，废话不多说，先使用Socket写一个Tomcat模型。</p>
<pre><code>class EmotionMaxFengTomcat{
   public void handlerClientRequest() throws IOException{
        //绑定端口
        ServerSocker serverSocket = new ServerSocket(8080);
        while(true){
         //接受客户端请求
        Socket socket = serverSocket.accept();
        request = socket.getInputStream();
        response = socket.getOutputStream();
        ...处理写入一些相应数据
        }
   }
}
</code></pre><p>上面的代码展示了一个简单的Client与Server端通信的代码，非常简单。但这是最基础的编程模型。我们完全可以在这个基础之上去优化。</p>
<h2 id="1：优化client发送过来的数据和server响应的数据模型。"><a href="#1：优化client发送过来的数据和server响应的数据模型。" class="headerlink" title="1：优化client发送过来的数据和server响应的数据模型。"></a>1：优化client发送过来的数据和server响应的数据模型。</h2><p>首先最基础的将请求对象和相应对象封装两个类。服务方法调用我们自定义的方法。将请求对象和响应对象放入在Servlet容器中，那么我们完全可以自己手写一个Servlet的基础类。此处代码省略。完成请求之后将response对象<br>包装秤socket对象发送给client。那么久完成了最简单的一次请求响应过程。</p>
<h2 id="2：优化IO通信方式"><a href="#2：优化IO通信方式" class="headerlink" title="2：优化IO通信方式"></a>2：优化IO通信方式</h2><p>可以更改为NIO的通信方式。Tomcat中的IO实现大概有四种，NIO，BIO，Apr，BIO在这个地方的是阻塞IO通信方式，在Tomcat中的实现类是JIoEndpoint.</p>
<h2 id="3：依据上面的编程模型，我们就可以开始Tomcat源码的切入点了。"><a href="#3：依据上面的编程模型，我们就可以开始Tomcat源码的切入点了。" class="headerlink" title="3：依据上面的编程模型，我们就可以开始Tomcat源码的切入点了。"></a>3：依据上面的编程模型，我们就可以开始Tomcat源码的切入点了。</h2><p>在第三篇文章中提到了Tomcat的配置文件server.xml。server.xml中提到了每一个标签源码会在源码中对应一个类，比如Server，Service，Context，Host、Engine，Wrapper等等.<br>我们好多人在server.xml中配置过一个东西，那就是发布项目的路径。如下代码：</p>
<pre><code>&lt;Context path=&quot;&quot; docBase=&quot;你的项目路径&quot; reloadable=&quot;true&quot;/&gt;
</code></pre><p>这个标签配置是被包含在Host标签中的，Context是比Host粒度更小的一种概念，既是一个Context就是一个项目，Tomcat可以同时发布多个项目，Host标签也可以有多个Context标签。我还说过依据更重要的话，那就是一个标签对应一个java中的一个类。那么我们去寻找Context这个类。</p>
<pre><code>/**
 * A &lt;b&gt;Context&lt;/b&gt; is a Container that represents a servlet context, and
 * therefore an individual web application, in the Catalina servlet engine.
 * It is therefore useful in almost every deployment of Catalina (even if a
 * Connector attached to a web server (such as Apache) uses the web server&apos;s
 * facilities to identify the appropriate Wrapper to handle this request.
 * It also provides a convenient mechanism to use Interceptors that see
 * every request processed by this particular web application.
 * &lt;p&gt;
 * The parent Container attached to a Context is generally a Host, but may
 * be some other implementation, or may be omitted if it is not necessary.
 * &lt;p&gt;
 * The child containers attached to a Context are generally implementations
 * of Wrapper (representing individual servlet definitions).
 * &lt;p&gt;
 *
 * @author Craig R. McClanahan
 */
public interface Context extends Container, ContextBind {...}
</code></pre><p>Context是一个接口，通过翻译注释：可以了解到Context是一个Servlet的上下文容器，他的父容器是Host，是一个单独的web应用程序，上下文是表示servlet上下文的容器因此是一个单独的web应用程序，在Catalina servlet引擎中。因此，它在几乎每一次加泰罗尼亚的部署中都是有用的连接到web服务器(如Apache)的连接器使用web服务器的连接器识别处理此请求的适当包装器的工具。它还提供了使用拦截器的方便机制此特定web应用程序处理的每个请求。连接到上下文的父容器通常是一个主机，但是可以是其他的一些实现，如果没有必要，可以省略。<br>附加到上下文的子容器通常是实现包装器(表示单个servlet定义)。</p>
<p>依照我们上面的分析思路，启动Tomcat必然先要初始化一系列的组件才可以启动，从上面的注释中我们得到了一个非常有用的信息，那就是跟Context相关的Catania组件。Catania组件是专门启动/停止Tomcat容器的组建类，下面代码所示Catalina的启动类代码：</p>
<pre><code>/**
 * Start a new server instance.
 */
public void start() {
    if (getServer() == null) {
        //加载一个Server实例
        load();
    }
    if (getServer() == null) {
        log.fatal(&quot;Cannot start server. Server instance is not configured.&quot;);
        return;
    }
    long t1 = System.nanoTime();
    // Start the new server
    try {
        getServer().start();
    } catch (LifecycleException e) {
        log.fatal(sm.getString(&quot;catalina.serverStartFail&quot;), e);
        try {
            getServer().destroy();
        } catch (LifecycleException e1) {
            log.debug(&quot;destroy() failed for failed Server &quot;, e1);
        }
        return;
    }
    long t2 = System.nanoTime();
    ...
}
</code></pre><p>Catalina第一步就调用了load方法去创建爱你一个新的Server。下面是load方法源码：</p>
<pre><code>if (loaded) {
           return;
       }
       loaded = true;
       long t1 = System.nanoTime();
       initDirs();
       initNaming();
       //解析xml配置文件的解析器
       Digester digester = createStartDigester();
       InputSource inputSource = null;
       InputStream inputStream = null;
       File file = null;
       try {
           try {
               //解析配置文件
               file = configFile();
               inputStream = new FileInputStream(file);
               inputSource = new InputSource(file.toURI().toURL().toString());
           } catch (Exception e) {
               if (log.isDebugEnabled()) {
                   log.debug(sm.getString(&quot;catalina.configFail&quot;, file), e);
               }
           }
          ...
   }
</code></pre><p>上面代码很清楚的看到了一个方法configFile(),下面所示configFile方法的源码：</p>
<pre><code>/**
 * Return a File object representing our configuration file.
 */
protected File configFile() {
    File file = new File(configFile);
    if (!file.isAbsolute()) {
        file = new File(Bootstrap.getCatalinaBase(), configFile);
    }
    return (file);
</code></pre><p>从这个方法看到了catalina解析的配置文件路径名称是configFile这个类变量。下面所示configFile类变量的值。</p>
<pre><code>/**
 * Pathname to the server configuration file.
 */
protected String configFile = &quot;conf/server.xml&quot;;
</code></pre><p>看到这个地方欣喜若狂，Tomcat源码启动的第一步是读取conf目录下的server.xml，使用Digester解析器解析配置文件。</p>
<p>解析配置文件完成之后第一步首先要绑定服务器的端口号，那么绑定端口号的代码去哪里找，聪明的人可能瞬间就想到了Tomcat的Connector组件，不错，Connector组件确实一步就可以找到绑定端口号的代码，那么本人也是不建议这么做的。前面说过了配置文件conf/server.xml一个标签对应一个java类，养成一个寻找源码的好习惯。</p>
<pre><code>&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre><p>这样是不是清晰明了，从上面的connector标签属性可以看到有端口，协议，连接超时时间，重定向端口。我们直接定位到Connector类查看源码。创建Connector对象有两个构造方法。如下：</p>
<pre><code>public Connector() {
    this(null);
}
public Connector(String protocol) {
    setProtocol(protocol);
    // Instantiate protocol handler
    ProtocolHandler p = null;
    try {
        Class&lt;?&gt; clazz = Class.forName(protocolHandlerClassName);
        p = (ProtocolHandler) clazz.getDeclaredConstructor().newInstance();
    } catch (Exception e) {
        log.error(sm.getString(
                &quot;coyoteConnector.protocolHandlerInstantiationFailed&quot;), e);
    } finally {
        this.protocolHandler = p;
    }

    if (!Globals.STRICT_SERVLET_COMPLIANCE) {
        URIEncoding = &quot;UTF-8&quot;;
        URIEncodingLower = URIEncoding.toLowerCase(Locale.ENGLISH);
    }
}
</code></pre><p>两个构造函数相当于一个。解析在创建Connector对象的时候，传入版本协议。构造完成Connector对象之后我们去看Connector的启动连接的处理方法，源码如下：</p>
<pre><code>/** 通过此连接开始处理请求
  * Begin processing requests via this Connector.
  *
  * @exception LifecycleException if a fatal startup error occurs
  */
 @Override
 protected void startInternal() throws LifecycleException {

     // Validate settings before starting
     if (getPort() &lt; 0) {
         throw new LifecycleException(sm.getString(
                 &quot;coyoteConnector.invalidPort&quot;, Integer.valueOf(getPort())));
     }

     setState(LifecycleState.STARTING);

     try {
         //调用端口绑定的方法
         protocolHandler.start();
     } catch (Exception e) {
         String errPrefix = &quot;&quot;;
         if(this.service != null) {
             errPrefix += &quot;service.getName(): \&quot;&quot; + this.service.getName() + &quot;\&quot;; &quot;;
         }

         throw new LifecycleException
             (errPrefix + &quot; &quot; + sm.getString
              (&quot;coyoteConnector.protocolHandlerStartFailed&quot;), e);
     }
 }
</code></pre><p>从一行简单的注释可以看到这个方法是启用当前连接对象处理请求，并且调用了端口绑定方法。protocolHandler.start();打开start()方法源码如下。结果我们发现start()这个方法是类ProtocolHandler的方法。这个接口的实现类非常的多，我们究竟去看哪一个？我们去默认实现类AbstractProtocol类中去看。</p>
<pre><code>@Override
public void start() throws Exception {
    if (getLog().isInfoEnabled())
        getLog().info(sm.getString(&quot;abstractProtocolHandler.start&quot;,
                getName()));
    try {
        //调用AbstractEndpoint的start（）启动连接
        endpoint.start();
    } catch (Exception ex) {
        getLog().error(sm.getString(&quot;abstractProtocolHandler.startError&quot;,
                getName()), ex);
        throw ex;
    }
}
</code></pre><p>在trycatch代码快中调用了AbstractEndpoint的start（）方法，start方法源码如下：</p>
<pre><code>public final void start() throws Exception {
       if (bindState == BindState.UNBOUND) {
           bind();
           bindState = BindState.BOUND_ON_START;
       }
       startInternal();
   }
</code></pre><p>可以看到它主要先判断端口是否已经被绑定，然后制定bind方法，如果不报异常，给这个端口加个已绑定的标记。bind方法是AbstractEndpoint类提供的，此方法是一个抽象方法，但是AbstractEndpoint子类非常多，我们去哪个类中查看bind方法的实现呢。我们刚开始写了一个java网络编程的一小段代码，我们用到的IO模型是BIO模型（阻塞模型），所以我们去JIoEndpoint这个类中去看,Jio意识就是java IO也就是BIO。<br>我们调到bind的方法查看源码如下：</p>
<pre><code>@Override
public void bind() throws Exception {

    // 初始化服务端线程数量
    if (acceptorThreadCount == 0) {
        acceptorThreadCount = 1;
    }
    // 初始化最大连接数
    if (getMaxConnections() == 0) {
        setMaxConnections(getMaxThreadsWithExecutor());
    }
    //创建ServerSocket工厂
    if (serverSocketFactory == null) {
        if (isSSLEnabled()) {
            serverSocketFactory =
                handler.getSslImplementation().getServerSocketFactory(this);
        } else {
            serverSocketFactory = new DefaultServerSocketFactory(this);
        }
    }
    if (serverSocket == null) {
        try {
            if (getAddress() == null) {
               //绑定端口
                serverSocket = serverSocketFactory.createSocket(getPort(),
                        getBacklog());
            } else {
                serverSocket = serverSocketFactory.createSocket(getPort(),
                        getBacklog(), getAddress());
            }
        } catch (BindException orig) {
            String msg;
            if (getAddress() == null)
                msg = orig.getMessage() + &quot; &lt;null&gt;:&quot; + getPort();
            else
                msg = orig.getMessage() + &quot; &quot; +
                        getAddress().toString() + &quot;:&quot; + getPort();
            BindException be = new BindException(msg);
            be.initCause(orig);
            throw be;
        }
    }
}
</code></pre><p>看到此处才一目了然，这就是最基本的基于BIO的端口绑定的代码。到此处才相当于我们上面写的ServerSocket serverSocket = new ServerSocket(8080);那么接受完请求之后，我们需要处理请求和响应。下一节将继续解析如何接受和处理请求的过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Emotion-maxfeng.github.io/Iblog/Iblog/2017/11/25/SpringBoot应用部署于外置Tomcat容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马雪峰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Iblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开源技术  乐于分享">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Iblog/2017/11/25/SpringBoot应用部署于外置Tomcat容器/" itemprop="url">SpringBoot应用部署于外置Tomcat容器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-25T13:53:25+08:00">
                2017-11-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SpringBoot使用了内置Tomcat，所以启动项目非常的慢，我们可以再开发期间将SpringBoot应用部署在外置Tomcat容器中。</p>
<h2 id="1：修改项目打包方式"><a href="#1：修改项目打包方式" class="headerlink" title="1：修改项目打包方式"></a>1：修改项目打包方式</h2><pre><code>&lt;groupId&gt;com.example&lt;/groupId&gt;
&lt;artifactId&gt;demo&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;packaging&gt;war&lt;/packaging&gt;
</code></pre><h2 id="2：移除内置Tomcat"><a href="#2：移除内置Tomcat" class="headerlink" title="2：移除内置Tomcat"></a>2：移除内置Tomcat</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;!-- 移除嵌入式tomcat插件 --&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre><h2 id="3：添加servlet-api依赖"><a href="#3：添加servlet-api依赖" class="headerlink" title="3：添加servlet-api依赖"></a>3：添加servlet-api依赖</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><h2 id="4：修改启动类，并重写初始化方法"><a href="#4：修改启动类，并重写初始化方法" class="headerlink" title="4：修改启动类，并重写初始化方法"></a>4：修改启动类，并重写初始化方法</h2><p>如下代码是SpringBoot应用的启动类，在这个类的同级下重写初始化方法。</p>
<pre><code>     @SpringBootApplication
        public class Application {
            public static void main(String[] args) {
                SpringApplication.run(Application.class, args);
            }
        }

// 修改启动类，继承 SpringBootServletInitializer 并重写 configure 方法，此类相当于web.xml
public class SpringBootStartApplication extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        // 注意这里一定要指向原先用main方法执行的Application启动类
        return builder.sources(Application.class);
    }
}
</code></pre><h2 id="5-打包验证"><a href="#5-打包验证" class="headerlink" title="5:打包验证"></a>5:打包验证</h2><p>执行mvn clean package,将打的到扔到tomcat中启动，访问测试。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Emotion-maxfeng.github.io/Iblog/Iblog/2017/11/23/SpringBoot和SpringMVC如何优雅处理全局异常/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马雪峰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Iblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开源技术  乐于分享">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Iblog/2017/11/23/SpringBoot和SpringMVC如何优雅处理全局异常/" itemprop="url">SSM处理全局异常和SpringBoot处理全局异常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-23T22:25:03+08:00">
                2017-11-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>全局异常处理对于每一个web应用来说至关重要，尤其对于用户体验而言，java程序猿固然有避免不了的异常错误。异常在java中大致分为两种。第一种就是可预料的错误即Exception，另一种是运行时错误，这个是无法预料的即RuntimeException，比如redis连接超时，内存溢出等等。针对于这样的情况，我们必须做出对应的处理。如今非常流行的MVC框架有SoringMVC和SpringBoot。这两个框架看似都是在使用SpringMVC来做前端控制器，但是他们的异常处理方式有一些差别，所以在此处列出来，防止一些同学搞不清楚。</p>
<h2 id="SpringMVC应用处理异常的方法。"><a href="#SpringMVC应用处理异常的方法。" class="headerlink" title="SpringMVC应用处理异常的方法。"></a>SpringMVC应用处理异常的方法。</h2><h2 id="1：springMVC可以基于web-xml来定义错误页面-如下："><a href="#1：springMVC可以基于web-xml来定义错误页面-如下：" class="headerlink" title="1：springMVC可以基于web.xml来定义错误页面 如下："></a>1：springMVC可以基于web.xml来定义错误页面 如下：</h2><pre><code>&lt;error-page&gt;
  &lt;error-code&gt;404&lt;/error-code&gt;
  &lt;location&gt;/resource/view/404.htm&lt;/location&gt;
&lt;/error-page&gt;
</code></pre><h2 id="2：第二种方式：基于拦截器实现"><a href="#2：第二种方式：基于拦截器实现" class="headerlink" title="2：第二种方式：基于拦截器实现"></a>2：第二种方式：基于拦截器实现</h2><pre><code>package com.maxfeng.ubuntu.core.security.interceptor;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Author： 橘温暖茶  时间：2017/7/24
 *
 * 专门处理各种冒泡的异常
 */
public class HandlerExceptionInterceptor implements HandlerInterceptor {


    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        if (response.getStatus() == 404){
            modelAndView.setViewName(&quot;cms/login&quot;);
        }
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}
</code></pre><h2 id="SpringBoot应用处理异常方法"><a href="#SpringBoot应用处理异常方法" class="headerlink" title="SpringBoot应用处理异常方法"></a>SpringBoot应用处理异常方法</h2><p>注意：SpringBoot2.0以上提供了两种web框架，一个是SpringMVC，另外一个是WebFlux函数框架（java世界的第一个函数式Web框架有兴趣的同学可以查查资料）。当然在这个地方只说SpringMVC的。</p>
<h2 id="1：根据SpringBoot继承的模板定义错误页面"><a href="#1：根据SpringBoot继承的模板定义错误页面" class="headerlink" title="1：根据SpringBoot继承的模板定义错误页面"></a>1：根据SpringBoot继承的模板定义错误页面</h2><p>默认情况下，SpringBoot提供了一个/error以合理方式处理所有错误的映射，并将其注册为servlet容器中的“全局”错误页面。对于计算机客户端，它会生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，有一个“whitelabel”错误视图，以HTML格式呈现相同的数据（以自定义它，添加View解析后的数据error）。要完全替换默认行为，您可以实现 ErrorController并注册该类型的bean定义，或者添加类型的bean   ErrorAttributes以使用现有机制但替换内容。<br>在BasicErrorController可以用作自定义基类 ErrorController。如果要为新内容类型添加处理程序（默认情况下是text/html专门处理并为其他所有内容提供后备），这将特别有用。为此，请扩展BasicErrorController，添加@RequestMapping具有produces属性的公共方法 ，并创建新类型的bean。</p>
<p>SpringBoot默认实现了接口ErrorController。ErrorController专门用户映射复杂的异常错误。BaseErrorController映射的错误路径为<br>${server.error.path:${error.path:/error}}，这是Spring的EL表达式。<br>表示的是对应SpringBoot默认模板的错误页面，即是在resources下的文件夹error中的404.html。具体可查阅官方文档，默认的页面类型是text/html,这样使得我们可以自定义错误页面。<br>当前映射到的error可以是jsp视图，也可以是控制器模型映射。非常方便。但是不都灵活。</p>
<p>##:2：SpringBoot中更灵活的异常处理方式 基于@ExceptionHandler ##</p>
<p>SpringBoot中提供了@ExceptionHandler注解，这样我们就可以针对于不同的错误进行不同的处理，不论是返回错误页面还是JSON数据类型。<br>如下代码所示：</p>
<pre><code>package com.maxfeng.ubuntu.core.exception;

import com.maxfeng.ubuntu.system.common.model.JsonResult;
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.IncorrectCredentialsException;
import org.apache.shiro.authc.LockedAccountException;
import org.apache.shiro.codec.CodecException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.xml.ws.Response;
import java.net.SocketTimeoutException;

/**
 * Author:MaXueFeng  2017/7/23
 * &lt;p&gt;
 * 全局异常处理
 */
@ControllerAdvice
public class GlobalExceptionHandler {

    Logger logger = LoggerFactory.getLogger(this.getClass());
   /* @ExceptionHandler(value = {RuntimeException.class})
    @ResponseBody
    public ResponseEntity&lt;?&gt; handlerRuntimeException(Exception e){
        return ResponseEntity.ok().body(&quot;服务器异常&quot;);
    }

    @ExceptionHandler(value = {Exception.class})
    @ResponseBody
    public ResponseEntity&lt;?&gt; handlerException(Exception e){
        return ResponseEntity.ok().body(&quot;服务器异常&quot;);
    }*/

    @ExceptionHandler(value = {AuthenticationException.class, IncorrectCredentialsException.class})
    @ResponseBody
    public ResponseEntity&lt;JsonResult&gt; handlerLoginException() {
        JsonResult jsonResult = new JsonResult();
        jsonResult.setStatus(403);
        jsonResult.setMessage(&quot;账号或者密码错误&quot;);
        return ResponseEntity.ok(jsonResult);
    }

    @ExceptionHandler(value = {LockedAccountException.class})
    @ResponseBody
    public ResponseEntity&lt;JsonResult&gt; handlerLockedException() {
        JsonResult jsonResult = new JsonResult();
        jsonResult.setStatus(403);
        jsonResult.setMessage(&quot;账号被冻结&quot;);
        return ResponseEntity.ok(jsonResult);
    }

    @ExceptionHandler(value = {SocketTimeoutException.class})
    @ResponseBody
    public ResponseEntity&lt;JsonResult&gt; handlerRedisTimeOutException() {
        JsonResult jsonResult = new JsonResult();
        jsonResult.setStatus(500);
        jsonResult.setMessage(&quot;redis链接超时&quot;);
        logger.error(&quot;socket读取超时  问题很严重哦！&quot;);
        return ResponseEntity.ok(jsonResult);
    }

    @ExceptionHandler(value = {CodecException.class})
    @ResponseBody
    public ResponseEntity&lt;JsonResult&gt; handlerCodeException(Throwable t) {
        JsonResult jsonResult = new JsonResult();
        jsonResult.setStatus(400);
        jsonResult.setMessage(t.getMessage());
        return ResponseEntity.ok(jsonResult);
    }
}
</code></pre><p>不论是运行时异常还是预料之内的异常都可以进行处理。</p>
<h2 id="3：SpringBoot基于异常解析器的异常处理"><a href="#3：SpringBoot基于异常解析器的异常处理" class="headerlink" title="3：SpringBoot基于异常解析器的异常处理"></a>3：SpringBoot基于异常解析器的异常处理</h2><pre><code>    package com.maxfeng.ubuntu.core.exception;

    import org.springframework.stereotype.Controller;
    import org.springframework.web.servlet.HandlerExceptionResolver;
    import org.springframework.web.servlet.ModelAndView;

    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;

    /**
     * Author： 橘温暖茶  时间：2017/7/27
     */
    @Controller
    public class CustomExceptionResolver implements HandlerExceptionResolver {

        @Override
        public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
            ModelAndView modelAndView = new ModelAndView();
            if (ex instanceof RuntimeException){
                modelAndView.setViewName(&quot;cms/login&quot;);
            }else{
                ...
            }
            return modelAndView;
        }
    }
将其配置到web项目中：
package com.maxfeng.ubuntu.config.web;

import com.maxfeng.ubuntu.core.exception.CustomExceptionResolver;
import com.maxfeng.ubuntu.core.security.interceptor.HandlerExceptionInterceptor;
import org.springframework.boot.autoconfigure.web.DefaultErrorAttributes;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

import java.util.List;

/**
 * Author： 橘温暖茶  时间：2017/6/17
 */
@Configuration
public class HRWebConfiguration extends WebMvcConfigurerAdapter {
 @Bean
    public CustomExceptionResolver customExceptionResolver() {
        return new CustomExceptionResolver();
    }

    @Override
    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; exceptionResolvers) {
        exceptionResolvers.add(customExceptionResolver());
    }
}
</code></pre><p>对于这种方式的异常处理需要说明几点。<br>异常解析器在SpringBoot中是一链的形式存在的，如果当前的异常解析解析完成之后返回的状态码还是一个异常的状态码。那么这个异常将继续向上冒泡到其他异常解析器。如果所有的异常解析器都完成之后还是存在异常状态码，那么将会上升到Servlet容器。交给Servlet容器去处理这样的异常。但是这种方法处理不了404异常。</p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>上面三种异常处理方都不能处理404错误，为什么不能解析404错误？<br>原因：DispacherServlet中有一个属性。</p>
<pre><code>/** Throw a NoHandlerFoundException if no Handler was found to process this request? **/
    private boolean throwExceptionIfNoHandlerFound = false;
</code></pre><p>这个属性在默认情况下为false。404异常发生之后并不会抛出异常。我们可以将其设置为true。<br>我们看一下DispacherServlet中的一个方法：</p>
<pre><code>protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {
        if (pageNotFoundLogger.isWarnEnabled()) {
            pageNotFoundLogger.warn(&quot;No mapping found for HTTP request with URI [&quot; + getRequestUri(request) +
                    &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);
        }
        if (this.throwExceptionIfNoHandlerFound) {
            throw new NoHandlerFoundException(request.getMethod(), getRequestUri(request),
                    new ServletServerHttpRequest(request).getHeaders());
        }
        else {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
        }
    }
</code></pre><p>如果this.throwExceptionIfNoHandlerFound = true的话，就会跑出NoHandlerFoundException异常。我们这个地方的需求当然是非常希望SpringMVC可以跑出异常我们在声明为@ControllerAdvice的类中来接收到这样的异常并且处理。聪明的读者可能就发现又有问题了。@ControllerAdvice声明的类只处理控制器层发生的异常，即RuntimeException异常。@ControllerAdvice底层是基于AOP来实现的。那么DispacherServlet算是控制器层吗？<br>当然算。DispacherServlet的原理就是一个Servlet。在Tomcat中控制器服务就是Servlet实现的。所以当然可以。<br>我们可以在application.yml文件中声明为<br>spring.mvc.throw-exception-if-no-handler-found: true<br>但是因为SpringBoot是一个非常优秀的框架，跑出异常没有用，默认的BasicErrorController会处理这个异常，返回到浏览器中的页面仍然不是自定义的。如果需要自定义模板，就需要实现ErrorController或者扩展BasicErrorController。</p>
<h2 id="4：基于EmbeddedServletContainerCustomizer实现"><a href="#4：基于EmbeddedServletContainerCustomizer实现" class="headerlink" title="4：基于EmbeddedServletContainerCustomizer实现"></a>4：基于EmbeddedServletContainerCustomizer实现</h2><p>Spring Boot默认使用嵌入式Tomcat，默认没有页面来处理404等常见错误。因此，为了给用户最佳的使用体验，404,500等常见错误需要我们自定义页面来处理。<br>我们需要用org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer类来实现该功能，在Spring Boot的配置类（@Configuration标注的类）当中，添加如下代码：</p>
<pre><code>//统一页码处理配置
    @Bean
    public EmbeddedServletContainerCustomizer containerCustomizer() {
        return new EmbeddedServletContainerCustomizer() {
            @Override
            public void customize(ConfigurableEmbeddedServletContainer container) {
                //ErrorPage error401Page = new ErrorPage(HttpStatus.UNAUTHORIZED, &quot;/401.html&quot;);
                ErrorPage error404Page = new ErrorPage(HttpStatus.NOT_FOUND, &quot;/Err404.html&quot;);
                ErrorPage error500Page = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, &quot;/Err500.html&quot;);

                container.addErrorPages( error404Page, error500Page);
            }
        };
    }
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Emotion-maxfeng.github.io/Iblog/Iblog/2017/10/14/SSM整合redis集群/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马雪峰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Iblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开源技术  乐于分享">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Iblog/2017/10/14/SSM整合redis集群/" itemprop="url">Shiro整合redisCluster</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T09:24:26+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>准备：</strong>  Ubuntu安装redis集群<br><strong>1： 安装ruby环境。</strong></p>
<pre><code>apt-get update
apt-get install ruby
apt-get install rubygems
</code></pre><p><strong>2:  下载安装redis</strong></p>
<pre><code>wget http://download.redis.io/releases/redis-4.0.10.tar.gz
tar xzf redis-4.0.10.tar.gz
cd redis-4.0.10
make &amp;&amp; make install --prefix=/usr/local/redis (编译安装位置)
</code></pre><p><strong>3：复制6个编译好的redis</strong></p>
<pre><code>cp -r /usr/local/redis/  /usr/local/redis-cluster/redis7001
cp -r /usr/local/redis/  /usr/local/redis-cluster/redis7002
cp -r /usr/local/redis/  /usr/local/redis-cluster/redis7003
cp -r /usr/local/redis/  /usr/local/redis-cluster/redis7004
cp -r /usr/local/redis/  /usr/local/redis-cluster/redis7005
cp -r /usr/local/redis/  /usr/local/redis-cluster/redis7006
</code></pre><p>为什么是6个？有兴趣的同学可以去了解下redis的crc16算法。6个redis集群节点三主三从。三是最小的大于1的奇数。所以必须是6个。三个redis节点投票才能判断出那个节点不能用了。</p>
<p><strong>4：修改每个redis节点的配置文件</strong></p>
<pre><code>1. 修改端口号  port   
2. 修改cluster-enabled yes
</code></pre><p><strong>5：启动所有节点</strong></p>
<p> 目前启动所有节点，这6个节点之间还不存在任何关系，我们需要到redis的解压目录中去，有一个文件叫做<br> red is-trib.rb，这个文件使用ruby语言编写的。专门用于启动redis集群，分配主从关系。<br> 启动命令：</p>
<pre><code>./redis-trib.rb create --replicas 1 192.168.56.181:7001 192.168.56.181:7002 192.168.56.18:7003 192.168.56.18:7004  192.168.56.18:7005  192.168.56.18:7006 
</code></pre><p>命令详解 create是创建一个备份集群节点。1代表每个主节点只有一个备份节点。后面的主机IP对应相应的端口号。到这基本环境就搭建完毕了。</p>
<p><strong>6：SSM整合Redis集群并且整合Shiro。</strong></p>
<p>*<bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"><br>    <property name="realm" ref="shiroDbRealm"></property><br>    <property name="sessionManager" ref="sessionManager"><br>    <property name="cacheManager" ref="redisCacheManager"><br></property></property></bean></p>
<p><bean id="sessionManager" class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager"><br>    <property name="sessionDAO" ref="sessionDAO"><br></property></bean></p>
<p><bean id="sessionDAO" class="com.zzkx.firegod.redis.IRedisSessionDao"><br>    <property name="redisManager" ref="clusterRedisManager"><br></property></bean></p>
<p><bean id="redisCacheManager" class="com.zzkx.firegod.redis.IRedisCacheManager"><br>    <property name="redisManager" ref="clusterRedisManager"><br></property></bean><br><!-- 单个节点--></p>
<p><bean class="org.crazycake.shiro.RedisManager" id="singleRedisManager"><br>    <property name="host" value="39.107.252.141"><br>    <property name="port" value="7000"><br>    <property name="timeout" value="60000"><br>    <property name="expire" value="300000"><br></property></property></property></property></bean><br>&lt;!– 集群节点  – &gt;</p>
<p><bean id="clusterRedisManager" class="com.zzkx.firegod.redis.IRedisManager"><br>    <property name="jedisCluster" ref="jedisCluster"><br>    <property name="expire" value="300000"><br>    <property name="timeout" value="6000"><br></property></property></property></bean><br><!--连接池配置--></p>
<p><bean id="jedisPool" class="redis.clients.jedis.JedisPoolConfig"><br>    <property name="maxTotal" value="${redis.maxTotal}"><br>    <property name="maxIdle" value="${redis.maxIdle}"><br>    <property name="maxWaitMillis" value="${redis.maxWait}"><br>    <property name="minIdle" value="${redis.minIdle}"><br></property></property></property></property></bean></p>
<p><bean class="redis.clients.jedis.JedisCluster" id="jedisCluster"><br>    <constructor-arg name="nodes"><br>        <set><br>            <bean class="redis.clients.jedis.HostAndPort"><br>                <constructor-arg name="host" value="39.107.252.141"><br>                <constructor-arg name="port" value="7001"><br>            </constructor-arg></constructor-arg></bean><br>            <bean class="redis.clients.jedis.HostAndPort"><br>                <constructor-arg name="host" value="39.107.252.141"><br>                <constructor-arg name="port" value="7002"><br>            </constructor-arg></constructor-arg></bean><br>            <bean class="redis.clients.jedis.HostAndPort"><br>                <constructor-arg name="host" value="39.107.252.141"><br>                <constructor-arg name="port" value="7003"><br>            </constructor-arg></constructor-arg></bean><br>            <bean class="redis.clients.jedis.HostAndPort"><br>                <constructor-arg name="host" value="39.107.252.141"><br>                <constructor-arg name="port" value="7004"><br>            </constructor-arg></constructor-arg></bean><br>            <bean class="redis.clients.jedis.HostAndPort"><br>                <constructor-arg name="host" value="39.107.252.141"><br>                <constructor-arg name="port" value="7005"><br>            </constructor-arg></constructor-arg></bean><br>            <bean class="redis.clients.jedis.HostAndPort"><br>                <constructor-arg name="host" value="39.107.252.141"><br>                <constructor-arg name="port" value="7006"><br>            </constructor-arg></constructor-arg></bean><br>        </set><br>    </constructor-arg><br>    <constructor-arg name="poolConfig" ref="jedisPool"><br></constructor-arg></bean>*</p>
<p><strong>7：集成Shiro代码实现</strong></p>
<p><strong>1：SessionDao</strong></p>
<pre><code>import org.apache.shiro.session.Session;
import org.apache.shiro.session.UnknownSessionException;
import org.apache.shiro.session.mgt.eis.AbstractSessionDAO;
import org.crazycake.shiro.RedisSessionDAO;
import org.crazycake.shiro.SerializeUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
    /**
     * Author:MaXueFeng  2017/10/13
     */
    public class IRedisSessionDao extends AbstractSessionDAO {

        private static Logger logger = LoggerFactory.getLogger(RedisSessionDAO.class);
        private IRedisManager redisManager;
        private String keyPrefix = &quot;shiro_redis_session:&quot;;
        public IRedisSessionDao() {
        }
        public void update(Session session) throws UnknownSessionException {
            this.saveSession(session);
        }
        private void saveSession(Session session) throws UnknownSessionException {
            if (session != null &amp;&amp; session.getId() != null) {
                byte[] key = this.getByteKey(session.getId());
                byte[] value = SerializeUtils.serialize(session);
                session.setTimeout((long)(this.redisManager.getExpire() * 1000));
                this.redisManager.set(key, value, this.redisManager.getExpire());
            } else {
                logger.error(&quot;session or session id is null&quot;);
            }
        }
        public void delete(Session session) {
            if (session != null &amp;&amp; session.getId() != null) {
                this.redisManager.del(this.getByteKey(session.getId()));
            } else {
                logger.error(&quot;session or session id is null&quot;);
            }
        }
        public Collection&lt;Session&gt; getActiveSessions() {
            Set&lt;Session&gt; sessions = new HashSet();
            Set&lt;byte[]&gt; keys = this.redisManager.keys(this.keyPrefix + &quot;*&quot;);
            if (keys != null &amp;&amp; keys.size() &gt; 0) {
                Iterator i$ = keys.iterator();

                while(i$.hasNext()) {
                    byte[] key = (byte[])i$.next();
                    Session s = (Session)SerializeUtils.deserialize(this.redisManager.get(key));
                    sessions.add(s);
                }
            }
            return sessions;
        }
        protected Serializable doCreate(Session session) {
            Serializable sessionId = this.generateSessionId(session);
            this.assignSessionId(session, sessionId);
            this.saveSession(session);
            return sessionId;
        }
        protected Session doReadSession(Serializable sessionId) {
            if (sessionId == null) {
                logger.error(&quot;session id is null&quot;);
                return null;
            } else {
                Session s = (Session)SerializeUtils.deserialize(this.redisManager.get(this.getByteKey(sessionId)));
                return s;
            }
        }
        private byte[] getByteKey(Serializable sessionId) {
            String preKey = this.keyPrefix + sessionId;
            return preKey.getBytes();
        }
        public IRedisManager getRedisManager() {
            return this.redisManager;
        }
        public void setRedisManager(IRedisManager redisManager) {
            this.redisManager = redisManager;
            this.redisManager.init();
        }
        public String getKeyPrefix() {
            return this.keyPrefix;
        }
        public void setKeyPrefix(String keyPrefix) {
            this.keyPrefix = keyPrefix;
        }
    }
**2：RedisCache**
package com.zzkx.firegod.redis;

import org.apache.shiro.cache.Cache;
import org.apache.shiro.cache.CacheException;
import org.apache.shiro.util.CollectionUtils;
import org.crazycake.shiro.SerializeUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

/**
 * Author:MaXueFeng  2018/7/13
 */
public class IRedisCache&lt;K, V&gt; implements Cache&lt;K, V&gt; {

    private Logger logger;
    private IRedisManager cache;
    private String keyPrefix;

    public String getKeyPrefix() {
        return this.keyPrefix;
    }

    public void setKeyPrefix(String keyPrefix) {
        this.keyPrefix = keyPrefix;
    }

    public IRedisCache(IRedisManager cache) {
        this.logger = LoggerFactory.getLogger(this.getClass());
        this.keyPrefix = &quot;shiro_redis_session:&quot;;
        if (cache == null) {
            throw new IllegalArgumentException(&quot;Cache argument cannot be null.&quot;);
        } else {
            this.cache = cache;
        }
    }

    public IRedisCache(IRedisManager cache, String prefix) {
        this(cache);
        this.keyPrefix = prefix;
    }

    private byte[] getByteKey(K key) {
        if (key instanceof String) {
            String preKey = this.keyPrefix + key;
            return preKey.getBytes();
        } else {
            return SerializeUtils.serialize(key);
        }
    }

    public V get(K key) throws CacheException {
        logger.info(&quot;===============================================&quot;);
        logger.info(&quot;===============================================&quot;);
        logger.info(&quot;===============================================&quot;);
        logger.info(&quot;===============================================&quot;);
        logger.info(&quot;===============================================&quot;);
        this.logger.debug(&quot;根据key从Redis中获取对象 key [&quot; + key + &quot;]&quot;);

        try {
            if (key == null) {
                return null;
            } else {
                byte[] rawValue = this.cache.get(this.getByteKey(key));
                V value = (V) SerializeUtils.deserialize(rawValue);
                return value;
            }
        } catch (Throwable var4) {
            throw new CacheException(var4);
        }
    }

    public V put(K key, V value) throws CacheException {
        this.logger.debug(&quot;根据key从存储 key [&quot; + key + &quot;]&quot;);

        try {
            this.cache.set(this.getByteKey(key), SerializeUtils.serialize(value));
            return value;
        } catch (Throwable var4) {
            throw new CacheException(var4);
        }
    }

    public V remove(K key) throws CacheException {
        this.logger.debug(&quot;从redis中删除 key [&quot; + key + &quot;]&quot;);

        try {
            V previous = this.get(key);
            this.cache.del(this.getByteKey(key));
            return previous;
        } catch (Throwable var3) {
            throw new CacheException(var3);
        }
    }

    public void clear() throws CacheException {
        this.logger.debug(&quot;从redis中删除所有元素&quot;);

        try {
            this.cache.flushDB();
        } catch (Throwable var2) {
            throw new CacheException(var2);
        }
    }

    public int size() {
        try {
            Long longSize = new Long(this.cache.dbSize());
            return longSize.intValue();
        } catch (Throwable var2) {
            throw new CacheException(var2);
        }
    }

    public Set&lt;K&gt; keys() {
        try {
            Set&lt;byte[]&gt; keys = this.cache.keys(this.keyPrefix + &quot;*&quot;);
            if (CollectionUtils.isEmpty(keys)) {
                return Collections.emptySet();
            } else {
                Set&lt;K&gt; newKeys = new HashSet();
                Iterator i$ = keys.iterator();

                while(i$.hasNext()) {
                    byte[] key = (byte[])i$.next();
                    newKeys.add((K) key);
                }

                return newKeys;
            }
        } catch (Throwable var5) {
            throw new CacheException(var5);
        }
    }

    public Collection&lt;V&gt; values() {
        try {
            Set&lt;byte[]&gt; keys = this.cache.keys(this.keyPrefix + &quot;*&quot;);
            if (!CollectionUtils.isEmpty(keys)) {
                List&lt;V&gt; values = new ArrayList(keys.size());
                Iterator i$ = keys.iterator();

                while(i$.hasNext()) {
                    byte[] key = (byte[])i$.next();
                    V value = this.get((K) key);
                    if (value != null) {
                        values.add(value);
                    }
                }

                return Collections.unmodifiableList(values);
            } else {
                return Collections.emptyList();
            }
        } catch (Throwable var6) {
            throw new CacheException(var6);
        }
    }
}
</code></pre><p><strong>3：CacheManager</strong></p>
<pre><code>import org.apache.shiro.cache.Cache;
import org.apache.shiro.cache.CacheException;
import org.apache.shiro.cache.CacheManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Author:MaXueFeng  2018/7/13
 */
public class IRedisCacheManager implements CacheManager {

    private static final Logger logger = LoggerFactory.getLogger(IRedisCacheManager.class);
    private final ConcurrentMap&lt;String, Cache&gt; caches = new ConcurrentHashMap();
    private IRedisManager redisManager;
    private String keyPrefix = &quot;shiro_redis_cache:&quot;;

    public IRedisCacheManager() {
    }

    public String getKeyPrefix() {
        return this.keyPrefix;
    }

    public void setKeyPrefix(String keyPrefix) {
        this.keyPrefix = keyPrefix;
    }

    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String name) throws CacheException {
        logger.debug(&quot;获取名称为: &quot; + name + &quot; 的RedisCache实例&quot;);
        Cache c = (Cache)this.caches.get(name);
        if (c == null) {
            this.redisManager.init();
            c = new IRedisCache(this.redisManager, this.keyPrefix);
            this.caches.put(name, c);
        }

        return (Cache)c;
    }

    public IRedisManager getRedisManager() {
        return this.redisManager;
    }

    public void setRedisManager(IRedisManager redisManager) {
        this.redisManager = redisManager;
    }
}
</code></pre><p><strong>4：RedisManager</strong></p>
<pre><code>import redis.clients.jedis.JedisCluster;
import java.util.Set;
/**
 * Author:MaXueFeng  2018/7/13
 */
public class IRedisManager {
    private int expire;
    private int timeout;

    public void init() {
        System.out.println(&quot;初始化===================================&quot;);
    }

    private JedisCluster jedisCluster;

    public JedisCluster getJedisCluster() {
        return jedisCluster;
    }
    public void setJedisCluster(JedisCluster jedisCluster) {
        this.jedisCluster = jedisCluster;
    }

    public byte[] get(byte[] key) {
        byte[] value;
        try {
            value = jedisCluster.get(key);
        } finally {
            System.out.println(&quot;==============================================&quot;);
        }

        return value;
    }

    public byte[] set(byte[] key, byte[] value) {
        jedisCluster.set(key, value);
        if (this.expire != 0) {
            jedisCluster.expire(key, this.expire);
        }
        return value;
    }

    public byte[] set(byte[] key, byte[] value, int expire) {

        try {
            jedisCluster.set(key, value);
            if (expire != 0) {
                jedisCluster.expire(key, expire);
            }
        } finally {
        }

        return value;
    }

    public void del(byte[] key) {

        try {
            jedisCluster.del(key);
        } finally {
            System.out.println(&quot;==============================================&quot;);
        }

    }

    public Set&lt;byte[]&gt; keys(String pattern) {
        Set&lt;byte[]&gt; keys = null;

        try {
            keys = jedisCluster.hkeys(pattern.getBytes());
        } finally {
            System.out.println(&quot;==============================================&quot;);
        }

        return keys;
    }
    public int getExpire() {
        return this.expire;
    }
    public void setExpire(int expire) {
        this.expire = expire;
    }
    public int getTimeout() {
        return this.timeout;
    }
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    public void flushDB() {
        this.jedisCluster.flushDB();
    }
    public long dbSize() {
        return this.jedisCluster.dbSize();
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Emotion-maxfeng.github.io/Iblog/Iblog/2017/09/11/Tomcat源码第三篇（启动与停止服务原理）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马雪峰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Iblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开源技术  乐于分享">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Iblog/2017/09/11/Tomcat源码第三篇（启动与停止服务原理）/" itemprop="url">Tomcat源码第三篇（启动与停止服务原理）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-11T15:54:47+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>前言：</strong><br>熟悉Tomcat的工程师们，肯定都知道Tomcat是如何启动与停止的。对于startup.sh、startup.bat、shutdown.sh、shutdown.bat等脚本或者批处理命令，大家一定知道改如何使用它，但是它们究竟是如何实现的，尤其是shutdown.sh脚本（或者shutdown.bat）究竟是如何和Tomcat进程通信的呢？本文将通过对Tomcat7.0的源码阅读，深入剖析这一过程。</p>
<p><strong>启动命令：</strong></p>
<p>./startup.sh</p>
<p><strong>startup.sh的代码清单如下：</strong></p>
<pre><code>os400=false
case &quot;`uname`&quot; in
OS400*) os400=true;;
esac

# resolve links - $0 may be a softlink
PRG=&quot;$0&quot;

while [ -h &quot;$PRG&quot; ] ; do
  ls=`ls -ld &quot;$PRG&quot;`
  link=`expr &quot;$ls&quot; : &apos;.*-&gt; \(.*\)$&apos;`
  if expr &quot;$link&quot; : &apos;/.*&apos; &gt; /dev/null; then
    PRG=&quot;$link&quot;
  else
    PRG=`dirname &quot;$PRG&quot;`/&quot;$link&quot;
  fi
done

PRGDIR=`dirname &quot;$PRG&quot;`
EXECUTABLE=catalina.sh

# Check that target executable exists
if $os400; then
  # -x will Only work on the os400 if the files are:
  # 1. owned by the user
  # 2. owned by the PRIMARY group of the user
  # this will not work if the user belongs in secondary groups
  eval
else
  if [ ! -x &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; ]; then
    echo &quot;Cannot find $PRGDIR/$EXECUTABLE&quot;
    echo &quot;The file is absent or does not have execute permission&quot;
    echo &quot;This file is needed to run this program&quot;
    exit 1
  fi
fi
exec &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; start &quot;$@&quot;
</code></pre><p>代码清单1中有两个主要的变量，分别是：<br>PRGDIR：当前shell脚本所在的路径；<br>EXECUTABLE：脚本catalina.sh。<br>根据最后一行代码：exec “$PRGDIR”/“$EXECUTABLE” start “$@”，我们知道执行了shell脚本catalina.sh，并且传递参数start。catalina.sh中接收到start参数后的执行的脚本分支见代码清单2。</p>
<p><strong>代码清单2</strong></p>
<pre><code>elif [ &quot;$1&quot; = &quot;start&quot; ] ; then

# 此处省略参数校验的脚本

shift
touch &quot;$CATALINA_OUT&quot;
if [ &quot;$1&quot; = &quot;-security&quot; ] ; then
  if [ $have_tty -eq 1 ]; then
    echo &quot;Using Security Manager&quot;
  fi
  shift
  eval &quot;\&quot;$_RUNJAVA\&quot;&quot; &quot;\&quot;$LOGGING_CONFIG\&quot;&quot; $LOGGING_MANAGER $JAVA_OPTS $CATALINA_OPTS \
    -Djava.endorsed.dirs=&quot;\&quot;$JAVA_ENDORSED_DIRS\&quot;&quot; -classpath &quot;\&quot;$CLASSPATH\&quot;&quot; \
    -Djava.security.manager \
    -Djava.security.policy==&quot;\&quot;$CATALINA_BASE/conf/catalina.policy\&quot;&quot; \
    -Dcatalina.base=&quot;\&quot;$CATALINA_BASE\&quot;&quot; \
    -Dcatalina.home=&quot;\&quot;$CATALINA_HOME\&quot;&quot; \
    -Djava.io.tmpdir=&quot;\&quot;$CATALINA_TMPDIR\&quot;&quot; \
    org.apache.catalina.startup.Bootstrap &quot;$@&quot; start \
    &gt;&gt; &quot;$CATALINA_OUT&quot; 2&gt;&amp;1 &quot;&amp;&quot;

else
  eval &quot;\&quot;$_RUNJAVA\&quot;&quot; &quot;\&quot;$LOGGING_CONFIG\&quot;&quot; $LOGGING_MANAGER $JAVA_OPTS $CATALINA_OPTS \
    -Djava.endorsed.dirs=&quot;\&quot;$JAVA_ENDORSED_DIRS\&quot;&quot; -classpath &quot;\&quot;$CLASSPATH\&quot;&quot; \
    -Dcatalina.base=&quot;\&quot;$CATALINA_BASE\&quot;&quot; \
    -Dcatalina.home=&quot;\&quot;$CATALINA_HOME\&quot;&quot; \
    -Djava.io.tmpdir=&quot;\&quot;$CATALINA_TMPDIR\&quot;&quot; \
    org.apache.catalina.startup.Bootstrap &quot;$@&quot; start \
    &gt;&gt; &quot;$CATALINA_OUT&quot; 2&gt;&amp;1 &quot;&amp;&quot;

fi

if [ ! -z &quot;$CATALINA_PID&quot; ]; then
  echo $! &gt; &quot;$CATALINA_PID&quot;
fi

echo &quot;Tomcat started.&quot;
</code></pre><p>从代码清单2可以看出，最终使用java命令执行了org.apache.catalina.startup.Bootstrap类中的main方法，参数也是start。Bootstrap的main方法的实现见代码清单3。<br>BootStrap类：<br>BootStrap类在初始化过程中，会先执行一段静态代码块：</p>
<pre><code>static {
    // Will always be non-null  获得用户目录位置
    String userDir = System.getProperty(&quot;user.dir&quot;);
    // Home first
    String home = System.getProperty(Globals.CATALINA_HOME_PROP);
    File homeFile = null;

    if (home != null) {
        File f = new File(home);
        try {
            homeFile = f.getCanonicalFile();
        } catch (IOException ioe) {
            homeFile = f.getAbsoluteFile();
        }
    }

    if (homeFile == null) {
        File bootstrapJar = new File(userDir, &quot;bootstrap.jar&quot;);
        if (bootstrapJar.exists()) {
            File f = new File(userDir, &quot;..&quot;);
            try {
                homeFile = f.getCanonicalFile();
            } catch (IOException ioe) {
                homeFile = f.getAbsoluteFile();
            }
        }
    }

    if (homeFile == null) {
        // Second fall-back. Use current directory
        File f = new File(userDir);
        try {
            homeFile = f.getCanonicalFile();
        } catch (IOException ioe) {
            homeFile = f.getAbsoluteFile();
        }
    }

    catalinaHomeFile = homeFile;
    System.setProperty(
            Globals.CATALINA_HOME_PROP, catalinaHomeFile.getPath());

    // Then base
    String base = System.getProperty(Globals.CATALINA_BASE_PROP);
    if (base == null) {
        catalinaBaseFile = catalinaHomeFile;
    } else {
        File baseFile = new File(base);
        try {
            baseFile = baseFile.getCanonicalFile();
        } catch (IOException ioe) {
            baseFile = baseFile.getAbsoluteFile();
        }
        catalinaBaseFile = baseFile;
    }
    System.setProperty(
            Globals.CATALINA_BASE_PROP, catalinaBaseFile.getPath());
}

    public static void main(String args[]) {

            if (daemon == null) {
                // Don&apos;t set daemon until init() has completed
                Bootstrap bootstrap = new Bootstrap();
                try {
                    bootstrap.init();
                } catch (Throwable t) {
                    handleThrowable(t);
                    t.printStackTrace();
                    return;
                }
                daemon = bootstrap;
            } else {
                // When running as a service the call to stop will be on a new
                // thread so make sure the correct class loader is used to prevent
                // a range of class not found exceptions.
                Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
            }

            try {
                String command = &quot;start&quot;;
                if (args.length &gt; 0) {
                    command = args[args.length - 1];
                }

                if (command.equals(&quot;startd&quot;)) {
                    args[args.length - 1] = &quot;start&quot;;
                    daemon.load(args);
                    daemon.start();
                } else if (command.equals(&quot;stopd&quot;)) {
                    args[args.length - 1] = &quot;stop&quot;;
                    daemon.stop();
                } else if (command.equals(&quot;start&quot;)) {
                    daemon.setAwait(true);
                    daemon.load(args);
                    daemon.start();
                } else if (command.equals(&quot;stop&quot;)) {
                    daemon.stopServer(args);
                } else if (command.equals(&quot;configtest&quot;)) {
                    daemon.load(args);
                    if (null==daemon.getServer()) {
                        System.exit(1);
                    }
                    System.exit(0);
                } else {
                    log.warn(&quot;Bootstrap: command \&quot;&quot; + command + &quot;\&quot; does not exist.&quot;);
                }
            } catch (Throwable t) {
                // Unwrap the Exception for clearer error reporting
                if (t instanceof InvocationTargetException &amp;&amp;
                        t.getCause() != null) {
                    t = t.getCause();
                }
                handleThrowable(t);
                t.printStackTrace();
                System.exit(1);
            }
        }
</code></pre><p>从代码清单3可以看出，当传递参数start的时候，command等于start，此时main方法的执行步骤如下：<br><strong>步骤一 初始化Bootstrap</strong><br>1：设置Catalina路径，默认为Tomcat的根目录；<br>2：初始化Tomcat的类加载器，并设置线程上下文类加载器；<br>3：用反射实例化org.apache.catalina.startup.Catalina对象，并且使用反射调用其setParentClassLoader方法，给Catalina对象设置Tomcat类加载体系的顶级加载器（Java自带的三种类加载器除外）。</p>
<pre><code>/**
 * Initialize daemon.
 */
public void init() throws Exception {
    initClassLoaders();
    Thread.currentThread().setContextClassLoader(catalinaLoader);
    SecurityClassLoad.securityClassLoad(catalinaLoader);
    // Load our startup class and call its process() method
    if (log.isDebugEnabled())
        log.debug(&quot;Loading startup class&quot;);
    Class&lt;?&gt; startupClass = catalinaLoader.loadClass(&quot;org.apache.catalina.startup.Catalina&quot;);
    Object startupInstance = startupClass.getConstructor().newInstance();

    // Set the shared extensions class loader
    if (log.isDebugEnabled())
        log.debug(&quot;Setting startup class properties&quot;);
    String methodName = &quot;setParentClassLoader&quot;;
    Class&lt;?&gt; paramTypes[] = new Class[1];
    paramTypes[0] = Class.forName(&quot;java.lang.ClassLoader&quot;);
    Object paramValues[] = new Object[1];
    paramValues[0] = sharedLoader;
    Method method =
        startupInstance.getClass().getMethod(methodName, paramTypes);
    method.invoke(startupInstance, paramValues);
    catalinaDaemon = startupInstance;
}
**步骤二 加载、解析server.xml配置文件**
</code></pre><p>当传递参数start的时候，会调用Bootstrap的load方法（见代码清单5），其作用是用反射调用catalinaDaemo（类型是Catalina）的load方法加载和解析server.xml配置文件。<br>    <strong>代码清单5</strong></p>
<pre><code>   /**
     * Load daemon.
     */
    private void load(String[] arguments)
        throws Exception {
    // Call the load() method
    String methodName = &quot;load&quot;;
    Object param[];
    Class&lt;?&gt; paramTypes[];
    if (arguments==null || arguments.length==0) {
        paramTypes = null;
        param = null;
    } else {
        paramTypes = new Class[1];
        paramTypes[0] = arguments.getClass();
        param = new Object[1];
        param[0] = arguments;
    }
    Method method = 
        catalinaDaemon.getClass().getMethod(methodName, paramTypes);
    if (log.isDebugEnabled())
        log.debug(&quot;Calling startup class &quot; + method);
    method.invoke(catalinaDaemon, param);
}
</code></pre><p><strong>步骤三 启动Tomcat</strong><br>当传递参数start的时候，调用Bootstrap的load方法之后会接着调用start方法（见代码清单6）启动Tomcat，此方法实际是用反射调用了catalinaDaemon（类型是Catalina）的start方法。</p>
<pre><code>/**
    * Start the Catalina daemon.
    */
   public void start()
       throws Exception {
       if( catalinaDaemon==null ) init();

       Method method = catalinaDaemon.getClass().getMethod(&quot;start&quot;, (Class [] )null);
       method.invoke(catalinaDaemon, (Object [])null);

   }
</code></pre><p><strong>Catalina的start方法（见代码清单7）的执行步骤如下：</strong><br>1：验证Server容器是否已经实例化。如果没有实例化Server容器，还会再次调用Catalina的load方法加载和解析server.xml，这也说明Tomcat只允许Server容器通过配置在server.xml的方式生成，用户也可以自己实现Server接口创建自定义的Server容器以取代默认的StandardServer。<br>2：启动Server容器。<br>3：设置关闭钩子。这么说可能有些不好理解，那就换个说法。Tomcat本身可能由于所在机器断点，程序bug甚至内存溢出导致进程退出，但是Tomcat可能需要在退出的时候做一些清理工作，比如：内存清理、对象销毁等。这些清理动作需要封装在一个Thread的实现中，然后将此Thread对象作为参数传递给Runtime的addShutdownHook方法即可。<br>4：最后调用Catalina的await方法循环等待接收Tomcat的shutdown命令。<br>5：如果Tomcat运行正常且没有收到shutdown命令，是不会向下执行stop方法的，当接收到shutdown命令，Catalina的await方法会退出循环等待，然后顺序执行stop方法停止Tomcat。</p>
<pre><code>/**
     * Start a new server instance.
     */
    public void start() {

        if (getServer() == null) {
            load();
        }

        if (getServer() == null) {
            log.fatal(&quot;Cannot start server. Server instance is not configured.&quot;);
            return;
        }

        long t1 = System.nanoTime();

        // Start the new server
        try {
            getServer().start();
        } catch (LifecycleException e) {
            log.error(&quot;Catalina.start: &quot;, e);
        }

        long t2 = System.nanoTime();
        if(log.isInfoEnabled())
            log.info(&quot;Server startup in &quot; + ((t2 - t1) / 1000000) + &quot; ms&quot;);

        try {
            // Register shutdown hook
            if (useShutdownHook) {
                if (shutdownHook == null) {
                    shutdownHook = new CatalinaShutdownHook();
                }
                Runtime.getRuntime().addShutdownHook(shutdownHook);

                // If JULI is being used, disable JULI&apos;s shutdown hook since
                // shutdown hooks run in parallel and log messages may be lost
                // if JULI&apos;s hook completes before the CatalinaShutdownHook()
                LogManager logManager = LogManager.getLogManager();
                if (logManager instanceof ClassLoaderLogManager) {
                    ((ClassLoaderLogManager) logManager).setUseShutdownHook(
                            false);
                }
            }
        } catch (Throwable t) {
            // This will fail on JDK 1.2. Ignoring, as Tomcat can run
            // fine without the shutdown hook.
        }

        if (await) {
            await();
            stop();
        }

    }
</code></pre><p>Catalina的await方法（见代码清单8）实际只是代理执行了Server容器的await方法。<br><strong>代码清单8</strong></p>
<pre><code>/**
 * Await and shutdown.
 */
public void await() {

    getServer().await();
}
</code></pre><p><strong>以Server的默认实现StandardServer为例，其await方法（见代码清单9）的执行步骤如下</strong>：<br>1：创建socket连接的服务端对象ServerSocket；<br>2：循环等待接收客户端发出的命令，如果接收到的命令与SHUTDOWN匹配（由于使用了equals，所以shutdown命令必须是大写的），那么退出循环等待。<br><strong>代码清单9</strong><br>public void await() {<br>        // Negative values - don’t wait on port - tomcat is embedded or we just don’t like ports gja<br>        if( port == -2 ) {<br>            // undocumented yet - for embedding apps that are around, alive.<br>            return;<br>        }<br>        if( port==-1 ) {<br>            while( true ) {<br>                try {<br>                    Thread.sleep( 10000 );<br>                } catch( InterruptedException ex ) {<br>                }<br>                if( stopAwait ) return;<br>            }<br>        }</p>
<pre><code>    // Set up a server socket to wait on
    ServerSocket serverSocket = null;
    try {
        serverSocket =
            new ServerSocket(port, 1,
                             InetAddress.getByName(address));
    } catch (IOException e) {
        log.error(&quot;StandardServer.await: create[&quot; + address
                           + &quot;:&quot; + port
                           + &quot;]: &quot;, e);
        System.exit(1);
    }

    // Loop waiting for a connection and a valid command
    while (true) {

        // Wait for the next connection
        Socket socket = null;
        InputStream stream = null;
        try {
            socket = serverSocket.accept();
            socket.setSoTimeout(10 * 1000);  // Ten seconds
            stream = socket.getInputStream();
        } catch (AccessControlException ace) {
            log.warn(&quot;StandardServer.accept security exception: &quot;
                               + ace.getMessage(), ace);
            continue;
        } catch (IOException e) {
            log.error(&quot;StandardServer.await: accept: &quot;, e);
            System.exit(1);
        }

        // Read a set of characters from the socket
        StringBuilder command = new StringBuilder();
        int expected = 1024; // Cut off to avoid DoS attack
        while (expected &lt; shutdown.length()) {
            if (random == null)
                random = new Random();
            expected += (random.nextInt() % 1024);
        }
        while (expected &gt; 0) {
            int ch = -1;
            try {
                ch = stream.read();
            } catch (IOException e) {
                log.warn(&quot;StandardServer.await: read: &quot;, e);
                ch = -1;
            }
            if (ch &lt; 32)  // Control character or EOF terminates loop
                break;
            command.append((char) ch);
            expected--;
        }

        // Close the socket now that we are done with it
        try {
            socket.close();
        } catch (IOException e) {
            // Ignore
        }

        // Match against our command string
        boolean match = command.toString().equals(shutdown);
        if (match) {
            log.info(sm.getString(&quot;standardServer.shutdownViaPort&quot;));
            break;
        } else
            log.warn(&quot;StandardServer.await: Invalid command &apos;&quot; +
                               command.toString() + &quot;&apos; received&quot;);

    }

    // Close the server socket and return
    try {
        serverSocket.close();
    } catch (IOException e) {
        // Ignore
    }

}
</code></pre><p>至此，Tomcat启动完毕。很多人可能会问，执行sh shutdown.sh脚本时，是如何与Tomcat进程通信的呢？如果要与Tomcat的ServerSocket通信，socket客户端如何知道服务端的连接地址与端口呢？下面会慢慢说明。</p>
<h2 id="停止过程分析"><a href="#停止过程分析" class="headerlink" title="停止过程分析"></a>停止过程分析</h2><p>停止Tomcat的命令如下：<br>./shutdownup.sh<br>所以，将从shell脚本shutdown.sh开始分析Tomcat的停止过程。shutdown.sh的脚本代码见代码清单10。<br><strong>代码清单10</strong><br>    os400=false<br>    case “<code>uname</code>“ in<br>    OS400*) os400=true;;<br>    esac</p>
<pre><code># resolve links - $0 may be a softlink
PRG=&quot;$0&quot;

while [ -h &quot;$PRG&quot; ] ; do
  ls=`ls -ld &quot;$PRG&quot;`
  link=`expr &quot;$ls&quot; : &apos;.*-&gt; \(.*\)$&apos;`
  if expr &quot;$link&quot; : &apos;/.*&apos; &gt; /dev/null; then
    PRG=&quot;$link&quot;
  else
    PRG=`dirname &quot;$PRG&quot;`/&quot;$link&quot;
  fi
done

PRGDIR=`dirname &quot;$PRG&quot;`
EXECUTABLE=catalina.sh

# Check that target executable exists
if $os400; then
  # -x will Only work on the os400 if the files are:
  # 1. owned by the user
  # 2. owned by the PRIMARY group of the user
  # this will not work if the user belongs in secondary groups
  eval
else
  if [ ! -x &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; ]; then
    echo &quot;Cannot find $PRGDIR/$EXECUTABLE&quot;
    echo &quot;The file is absent or does not have execute permission&quot;
    echo &quot;This file is needed to run this program&quot;
    exit 1
  fi
fi

exec &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; stop &quot;$@&quot;
</code></pre><p>代码清单10和代码清单1非常相似，其中也有两个主要的变量，分别是：<br>PRGDIR：当前shell脚本所在的路径；<br>EXECUTABLE：脚本catalina.sh。<br>根据最后一行代码：exec “$PRGDIR”/“$EXECUTABLE” stop “$@”，我们知道执行了shell脚本catalina.sh，并且传递参数stop。catalina.sh中接收到stop参数后的执行的脚本分支见代码清单11。</p>
<p><strong>代码清单十一</strong></p>
<pre><code>elif [ &quot;$1&quot; = &quot;stop&quot; ] ; then

  #省略参数校验脚本

  eval &quot;\&quot;$_RUNJAVA\&quot;&quot; $LOGGING_MANAGER $JAVA_OPTS \
    -Djava.endorsed.dirs=&quot;\&quot;$JAVA_ENDORSED_DIRS\&quot;&quot; -classpath &quot;\&quot;$CLASSPATH\&quot;&quot; \
    -Dcatalina.base=&quot;\&quot;$CATALINA_BASE\&quot;&quot; \
    -Dcatalina.home=&quot;\&quot;$CATALINA_HOME\&quot;&quot; \
    -Djava.io.tmpdir=&quot;\&quot;$CATALINA_TMPDIR\&quot;&quot; \
    org.apache.catalina.startup.Bootstrap &quot;$@&quot; stop
</code></pre><p>从代码清单11可以看出，最终使用java命令执行了org.apache.catalina.startup.Bootstrap类中的main方法，参数是stop。从代码清单3可以看出，当传递参数stop的时候，command等于stop，此时main方法的执行步骤如下：</p>
<p><strong>步骤一 初始化Bootstrap</strong><br>　　已经在启动过程分析中介绍， 不再赘述。<br>　　<br><strong>步骤二 停止服务</strong><br>　　通过调用Bootstrap的stopServer方法（见代码清单12）停止Tomcat，其实质是用反射调用catalinaDaemon（类型是Catalina）的stopServer方法。<br>　　<strong>代码清单12</strong></p>
<p>　　/**</p>
<ul>
<li><p>Stop the standalone server.<br>*/<br>public void stopServer(String[] arguments)<br> throws Exception {</p>
<p> Object param[];<br> Class&lt;?&gt; paramTypes[];<br> if (arguments==null || arguments.length==0) {</p>
<pre><code>paramTypes = null;
param = null;
</code></pre><p> } else {</p>
<pre><code>paramTypes = new Class[1];
paramTypes[0] = arguments.getClass();
param = new Object[1];
param[0] = arguments;
</code></pre><p> }<br> Method method = </p>
<pre><code>catalinaDaemon.getClass().getMethod(&quot;stopServer&quot;, paramTypes);
</code></pre><p> method.invoke(catalinaDaemon, param);</p>
</li>
</ul>
<p>}</p>
<p>Catalina的stopServer方法（见代码清单13）的执行步骤如下：<br>创建Digester解析server.xml文件（此处只解析标签），以构造出Server容器（此时Server容器的子容器没有被实例化）；<br>从实例化的Server容器获取Server的socket监听端口和地址，然后创建Socket对象连接启动Tomcat时创建的ServerSocket，最后向ServerSocket发送SHUTDOWN命令。根据代码清单9的内容，ServerSocket循环等待接收到SHUTDOWN命令后，最终调用stop方法停止Tomcat。</p>
<p><strong>代码清单13</strong></p>
<pre><code>public void stopServer() {
       stopServer(null);
   }

   public void stopServer(String[] arguments) {

       if (arguments != null) {
           arguments(arguments);
       }

       if( getServer() == null ) {
           // Create and execute our Digester
           Digester digester = createStopDigester();
           digester.setClassLoader(Thread.currentThread().getContextClassLoader());
           File file = configFile();
           try {
               InputSource is =
                   new InputSource(&quot;file://&quot; + file.getAbsolutePath());
               FileInputStream fis = new FileInputStream(file);
               is.setByteStream(fis);
               digester.push(this);
               digester.parse(is);
               fis.close();
           } catch (Exception e) {
               log.error(&quot;Catalina.stop: &quot;, e);
               System.exit(1);
           }
       }

       // Stop the existing server
       try {
           if (getServer().getPort()&gt;0) { 
               Socket socket = new Socket(getServer().getAddress(),
                       getServer().getPort());
               OutputStream stream = socket.getOutputStream();
               String shutdown = getServer().getShutdown();
               for (int i = 0; i &lt; shutdown.length(); i++)
                   stream.write(shutdown.charAt(i));
               stream.flush();
               stream.close();
               socket.close();
           } else {
               log.error(sm.getString(&quot;catalina.stopServer&quot;));
               System.exit(1);
           }
       } catch (IOException e) {
           log.error(&quot;Catalina.stop: &quot;, e);
           System.exit(1);
       }
   }
</code></pre><p>最后，我们看看Catalina的stop方法（见代码清单14）的实现，其执行步骤如下：<br>将启动过程中添加的关闭钩子移除。<br>1：Tomcat启动过程辛辛苦苦添加的关闭钩子为什么又要去掉呢？因为关闭钩子是为了在JVM异常退出后，进行资源的回收工作。主动停止Tomcat时调用的stop方法里已经包含了资源回收的内容，所以不再需要这个钩子了。<br>2：停止容器</p>
<p><strong>代码清单14</strong></p>
<pre><code>/**
 * Stop an existing server instance.
 */
public void stop() {

    try {
        // Remove the ShutdownHook first so that server.stop() 
        // doesn&apos;t get invoked twice
        if (useShutdownHook) {
            Runtime.getRuntime().removeShutdownHook(shutdownHook);

            // If JULI is being used, re-enable JULI&apos;s shutdown to ensure
            // log messages are not lost jiaan
            LogManager logManager = LogManager.getLogManager();
            if (logManager instanceof ClassLoaderLogManager) {
                ((ClassLoaderLogManager) logManager).setUseShutdownHook(
                        true);
            }
        }
    } catch (Throwable t) {
        // This will fail on JDK 1.2. Ignoring, as Tomcat can run
        // fine without the shutdown hook.
    }

    // Shut down the server
    try {
        getServer().stop();
    } catch (LifecycleException e) {
        log.error(&quot;Catalina.stop&quot;, e);
    }

}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对Tomcat源码的分析我们了解到Tomcat的启动和停止都离不开org.apache.catalina.startup.Bootstrap。当停止Tomcat时，已经启动的Tomcat作为socket服务端，停止脚本启动的Bootstrap进程作为socket客户端向服务端发送shutdown命令，两个进程通过共享server.xml里Server标签的端口以及地址信息打通了socket的通信。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Emotion-maxfeng.github.io/Iblog/Iblog/2017/08/14/Tomcat源码第二篇（Service和Server之间的关系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马雪峰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Iblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开源技术  乐于分享">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Iblog/2017/08/14/Tomcat源码第二篇（Service和Server之间的关系/" itemprop="url">Tomcat源码第二篇（Service和Server之间的关系）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T18:50:40+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>server和service的作用是什么？</strong><br>Catalina主要包括connector和container两个模块，connector负责接收请求，传递给container，而container负责处理请求。service的作用是统一管理connector和container，一个service可以包括多个connector和一个container。而server的作用是，管理所有的service，一个server可以包括多个service。server负责管理所有service的生命周期，这样就管理了所有的connector和container，以及connector和container的所有内部组件。这样就不需要单独对connector和container单独进行开启或关闭了。<br><strong>主要流程</strong><br>初始化server：</p>
<pre><code>/**
 * Invoke a pre-startup initialization. This is used to allow connectors
 * to bind to restricted ports under Unix operating environments.
 */
public void initialize()
throws LifecycleException {
    if (initialized)
        throw new LifecycleException (
            sm.getString(&quot;standardServer.initialize.initialized&quot;));
    initialized = true;

    // Initialize our defined Services
    for (int i = 0; i &lt; services.length; i++) {
        services[i].initialize();
    }
}
</code></pre><p>初始化Service</p>
<pre><code>/**
 * Invoke a pre-startup initialization. This is used to allow connectors
 * to bind to restricted ports under Unix operating environments.
 */
public void initialize()
throws LifecycleException {
    if (initialized)
        throw new LifecycleException (
            sm.getString(&quot;standardService.initialize.initialized&quot;));
    initialized = true;

    // Initialize our defined Connectors
    synchronized (connectors) {
            for (int i = 0; i &lt; connectors.length; i++) {
                connectors[i].initialize();
            }
    }
}
启动Server
  /**
 * Prepare for the beginning of active use of the public methods of this
 * component.  This method should be called before any of the public
 * methods of this component are utilized.  It should also send a
 * LifecycleEvent of type START_EVENT to any registered listeners.
 *
 * @exception LifecycleException if this component detects a fatal error
 *  that prevents this component from being used
 */
public void start() throws LifecycleException {

    // Validate and update our current component state
    if (started)
        throw new LifecycleException
            (sm.getString(&quot;standardServer.start.started&quot;));
    // Notify our interested LifecycleListeners
    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);

    lifecycle.fireLifecycleEvent(START_EVENT, null);
    started = true;

    // Start our defined Services
    synchronized (services) {
        for (int i = 0; i &lt; services.length; i++) {
            if (services[i] instanceof Lifecycle)
                ((Lifecycle) services[i]).start();
        }
    }

    // Notify our interested LifecycleListeners
    lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);
}
启动service
    /**
 * Prepare for the beginning of active use of the public methods of this
 * component.  This method should be called before any of the public
 * methods of this component are utilized.  It should also send a
 * LifecycleEvent of type START_EVENT to any registered listeners.
 *
 * @exception LifecycleException if this component detects a fatal error
 *  that prevents this component from being used
 */
public void start() throws LifecycleException {

    // Validate and update our current component state
    if (started) {
        throw new LifecycleException
            (sm.getString(&quot;standardService.start.started&quot;));
    }

    // Notify our interested LifecycleListeners
    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);

    System.out.println
        (sm.getString(&quot;standardService.start.name&quot;, this.name));
    lifecycle.fireLifecycleEvent(START_EVENT, null);
    started = true;

    // Start our defined Container first
    if (container != null) {
        synchronized (container) {
            if (container instanceof Lifecycle) {
                ((Lifecycle) container).start();
            }
        }
    }

    // Start our defined Connectors second
    synchronized (connectors) {
        for (int i = 0; i &lt; connectors.length; i++) {
            if (connectors[i] instanceof Lifecycle)
                ((Lifecycle) connectors[i]).start();
        }
    }

    // Notify our interested LifecycleListeners
    lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);

}
</code></pre><p> server.await()，监听8005端口消息，若收到shutdown命令，就关闭serversocket，并返回。Bootstrap.main()中，从StandardServer.await()返回后，会执行StandardServer.stop()，就可以关闭所有service了。</p>
<pre><code> /**
 * Wait until a proper shutdown command is received, then return.
 */
public void await() {

    // Set up a server socket to wait on
    // 监听8005端口
    ServerSocket serverSocket = null;
    try {
        serverSocket =
            new ServerSocket(port, 1,
                             InetAddress.getByName(&quot;127.0.0.1&quot;));
    } catch (IOException e) {
        System.err.println(&quot;StandardServer.await: create[&quot; + port
                           + &quot;]: &quot; + e);
        e.printStackTrace();
        System.exit(1);
    }

    // Loop waiting for a connection and a valid command
    while (true) {

        // Wait for the next connection
        Socket socket = null;
        InputStream stream = null;
        try {
            socket = serverSocket.accept();
            socket.setSoTimeout(10 * 1000);  // Ten seconds
            stream = socket.getInputStream();
        } catch (AccessControlException ace) {
            System.err.println(&quot;StandardServer.accept security exception: &quot;
                               + ace.getMessage());
            continue;
        } catch (IOException e) {
            System.err.println(&quot;StandardServer.await: accept: &quot; + e);
            e.printStackTrace();
            System.exit(1);
        }

        // Read a set of characters from the socket
        StringBuffer command = new StringBuffer();
        int expected = 1024; // Cut off to avoid DoS attack
        while (expected &lt; shutdown.length()) {
            if (random == null)
                random = new Random(System.currentTimeMillis());
            expected += (random.nextInt() % 1024);
        }
        while (expected &gt; 0) {
            int ch = -1;
            try {
                ch = stream.read();
            } catch (IOException e) {
                System.err.println(&quot;StandardServer.await: read: &quot; + e);
                e.printStackTrace();
                ch = -1;
            }
            if (ch &lt; 32)  // Control character or EOF terminates loop
                break;
            command.append((char) ch);
            expected--;
        }

        // Close the socket now that we are done with it
        try {
            socket.close();
        } catch (IOException e) {
            ;
        }

        // Match against our command string
        System.out.println(&quot;[StandardServer] command: &quot; + command);
        boolean match = command.toString().equals(shutdown);
        if (match) {
            break;
        } else
            System.err.println(&quot;StandardServer.await: Invalid command &apos;&quot; +
                               command.toString() + &quot;&apos; received&quot;);

    }

    // Close the server socket and return
    try {
        serverSocket.close();
    } catch (IOException e) {
        ;
    }

}
</code></pre><p>一个service可以包括多个connector和一个container，一个connector收到请求后将它发给container处理，service怎么样将connector和container关联起来呢？<br>在service.setContainer()中，会关联二者。</p>
<pre><code>/**
 * Set the &lt;code&gt;Container&lt;/code&gt; that handles requests for all
 * &lt;code&gt;Connectors&lt;/code&gt; associated with this Service.
 *
 * @param container The new Container
 */
public void setContainer(Container container) {

    Container oldContainer = this.container;
    if ((oldContainer != null) &amp;&amp; (oldContainer instanceof Engine))
        ((Engine) oldContainer).setService(null);
    this.container = container;
    if ((this.container != null) &amp;&amp; (this.container instanceof Engine))
        ((Engine) this.container).setService(this);
    if (started &amp;&amp; (this.container != null) &amp;&amp;
        (this.container instanceof Lifecycle)) {
        try {
            ((Lifecycle) this.container).start();
        } catch (LifecycleException e) {
            ;
        }
    }
    synchronized (connectors) {
        for (int i = 0; i &lt; connectors.length; i++)
            connectors[i].setContainer(this.container);
    }
    if (started &amp;&amp; (oldContainer != null) &amp;&amp;
        (oldContainer instanceof Lifecycle)) {
        try {
            ((Lifecycle) oldContainer).stop();
        } catch (LifecycleException e) {
            ;
        }
    }

    // Report this property change to interested listeners
    support.firePropertyChange(&quot;container&quot;, oldContainer, this.container);
}
</code></pre><p>从await()返回后，调用server.stop()</p>
<pre><code>// Start the new server
if (server instanceof Lifecycle) {
  try {
    server.initialize();
    ((Lifecycle) server).start();
    server.await();
    // the program waits until the await method returns,
    // i.e. until a shutdown command is received.
  }
  catch (LifecycleException e) {
    e.printStackTrace(System.out);
  }
}

// Shut down the server
if (server instanceof Lifecycle) {
  try {
    ((Lifecycle) server).stop();
  }
  catch (LifecycleException e) {
    e.printStackTrace(System.out);
  }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Emotion-maxfeng.github.io/Iblog/Iblog/2017/07/24/Tomcat源码第一篇（Tomcat基本架构）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马雪峰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Iblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开源技术  乐于分享">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Iblog/2017/07/24/Tomcat源码第一篇（Tomcat基本架构）/" itemprop="url">Tomcat源码第一篇（基本架构）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-24T18:50:40+08:00">
                2017-07-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  Tomcat是java世界非常流行的服务器软件，作为一个java程序员，除了会写两个MVC之外，对于底层的东西一无所知，可能学习底层的东西对于你编写业务代码没有什么用，但是就行侠客相逢，拼实力的时候才知道基础只是扎实，才会胜利！<br>  Tomcat的总体架构图如下图所示：<br>  ![Tomcat组件架构图][1]<br>  [1]: <a href="https://img-blog.csdn.net/20150810083413467" target="_blank" rel="noopener">https://img-blog.csdn.net/20150810083413467</a><br>  <strong>架构模式简单介绍：</strong><br>  Tomcat整个架构是按照组件来进行划分的，顶级组件是Server，Server控制着所有组件的生命周期，包括组件初始化，组件启动运行，组件停止，组件销毁。可以看出主要的组件是Server，Service，Engine，Connector，Container，Context。Server装配多个Service服务，当请求进来之后，Server负责通过一系列的操作将请求交给相应的服务。<br> 在Tomcat的配置文件server.xml可以发现上述的组件的层次结构。</p>
<pre><code>&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;
&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
  &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;
  &lt;!-- Security listener. Documentation at /docs/config/listeners.html
  &lt;Listener className=&quot;org.apache.catalina.security.SecurityListener&quot; /&gt;
  --&gt;
  &lt;!--APR library loader. Documentation at /docs/apr.html --&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;
  &lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;
  &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;

  &lt;!-- Global JNDI resources
       Documentation at /docs/jndi-resources-howto.html
  --&gt;
  &lt;GlobalNamingResources&gt;
    &lt;!-- Editable user database that can also be used by
         UserDatabaseRealm to authenticate users
    --&gt;
    &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;
              type=&quot;org.apache.catalina.UserDatabase&quot;
              description=&quot;User database that can be updated and saved&quot;
              factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;
              pathname=&quot;conf/tomcat-users.xml&quot; /&gt;
  &lt;/GlobalNamingResources&gt;

  &lt;!-- A &quot;Service&quot; is a collection of one or more &quot;Connectors&quot; that share
       a single &quot;Container&quot; Note:  A &quot;Service&quot; is not itself a &quot;Container&quot;,
       so you may not define subcomponents such as &quot;Valves&quot; at this level.
       Documentation at /docs/config/service.html
   --&gt;
  &lt;Service name=&quot;Catalina&quot;&gt;

    &lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;
    &lt;!--
    &lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot;
        maxThreads=&quot;150&quot; minSpareThreads=&quot;4&quot;/&gt;
    --&gt;


    &lt;!-- A &quot;Connector&quot; represents an endpoint by which requests are received
         and responses are returned. Documentation at :
         Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking)
         Java AJP  Connector: /docs/config/ajp.html
         APR (HTTP/AJP) Connector: /docs/apr.html
         Define a non-SSL/TLS HTTP/1.1 Connector on port 8080
    --&gt;
    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
               connectionTimeout=&quot;20000&quot;
               redirectPort=&quot;8443&quot; /&gt;
    &lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;
    &lt;!--
    &lt;Connector executor=&quot;tomcatThreadPool&quot;
               port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
               connectionTimeout=&quot;20000&quot;
               redirectPort=&quot;8443&quot; /&gt;
    --&gt;
    &lt;!-- Define a SSL/TLS HTTP/1.1 Connector on port 8443
         This connector uses the NIO implementation that requires the JSSE
         style configuration. When using the APR/native implementation, the
         OpenSSL style configuration is required as described in the APR/native
         documentation --&gt;
    &lt;!--
    &lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;
               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
               clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt;
    --&gt;

    &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;
    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;


    &lt;!-- An Engine represents the entry point (within Catalina) that processes
         every request.  The Engine implementation for Tomcat stand alone
         analyzes the HTTP headers included with the request, and passes them
         on to the appropriate Host (virtual host).
         Documentation at /docs/config/engine.html --&gt;

    &lt;!-- You should set jvmRoute to support load-balancing via AJP ie :
    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;jvm1&quot;&gt;
    --&gt;
    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;

      &lt;!--For clustering, please take a look at documentation at:
          /docs/cluster-howto.html  (simple how to)
          /docs/config/cluster.html (reference documentation) --&gt;
      &lt;!--
      &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;/&gt;
      --&gt;

      &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords
           via a brute-force attack --&gt;
      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;
        &lt;!-- This Realm uses the UserDatabase configured in the global JNDI
             resources under the key &quot;UserDatabase&quot;.  Any edits
             that are performed against this UserDatabase are immediately
             available for use by the Realm.  --&gt;
        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;
               resourceName=&quot;UserDatabase&quot;/&gt;
      &lt;/Realm&gt;

      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;
            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;

        &lt;!-- SingleSignOn valve, share authentication between web applications
             Documentation at: /docs/config/valve.html --&gt;
        &lt;!--
        &lt;Valve className=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&gt;
        --&gt;

        &lt;!-- Access log processes all example.
             Documentation at: /docs/config/valve.html
             Note: The pattern used is equivalent to using pattern=&quot;common&quot; --&gt;
        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;
      &lt;/Host&gt;
    &lt;/Engine&gt;
  &lt;/Service&gt;
&lt;/Server&gt;
</code></pre><blockquote>
<p>可以非常清楚的看到Tomcat容器组件包含层次结构。依据这样的结构我们去分析Tomcat的组件接口结构。<br>Tomcat的顶级接口是Lifecycle。这个接口控制所有组件的生命周期。</p>
</blockquote>
<pre><code>public interface Lifecycle {
/**
 * 下面的常量都是组件生命周期状态的标记
 */
public static final String BEFORE_INIT_EVENT = &quot;before_init&quot;;

public static final String AFTER_INIT_EVENT = &quot;after_init&quot;;

public static final String START_EVENT = &quot;start&quot;;

public static final String BEFORE_START_EVENT = &quot;before_start&quot;;

public static final String AFTER_START_EVENT = &quot;after_start&quot;;

public static final String STOP_EVENT = &quot;stop&quot;;

public static final String BEFORE_STOP_EVENT = &quot;before_stop&quot;;

public static final String AFTER_STOP_EVENT = &quot;after_stop&quot;;

public static final String AFTER_DESTROY_EVENT = &quot;after_destroy&quot;;

public static final String BEFORE_DESTROY_EVENT = &quot;before_destroy&quot;;

/**
 * 生命周期事件
 */
public static final String PERIODIC_EVENT = &quot;periodic&quot;;

/**
 * The LifecycleEvent type for the &quot;configure_start&quot; event. Used by those
 * components that use a separate component to perform configuration and
 * need to signal when configuration should be performed - usually after
 * **{@link #BEFORE_START_EVENT} and before {@link #START_EVENT}.**
 */
public static final String CONFIGURE_START_EVENT = &quot;configure_start&quot;;

/**
 * The LifecycleEvent type for the &quot;configure_stop&quot; event. Used by those
 * components that use a separate component to perform configuration and
 * need to signal when de-configuration should be performed - usually after
 * *{@link #STOP_EVENT} and before {@link #AFTER_STOP_EVENT}.*
 */
public static final String CONFIGURE_STOP_EVENT = &quot;configure_stop&quot;;

/**
   添加监听器
 */
public void addLifecycleListener(LifecycleListener listener);

/**
  查找所有的组件监听器
 */
public LifecycleListener[] findLifecycleListeners();

/**
   移除
 */
public void removeLifecycleListener(LifecycleListener listener);

/**
 *   初始化
 */
public void init() throws LifecycleException;

/**
  启动
 */
public void start() throws LifecycleException;

/**
 停止
 */
public void stop() throws LifecycleException;

/**
  获取组件状态
 */
public LifecycleState getState();

public String getStateName();

/**
  标记接口用于指示应该只使用实例一次
 */
public interface SingleUse {
}
</code></pre><p>}</p>
<blockquote>
<p>Tomcat的每个组件之间的通信依赖于事件监听LifecycleEvent。通过事件监听来相互传递信息。Lifecycle的下级重要接口：<br>1：Server: 这个接口主要的作用是设置容器的class加载器，设置端口，设置访问地址，执行杀死容器命令。StandardServer是Server的标准实现。<br>2：Service：跟Container相关，主要负责容器中的服务分配。<br>3: Container：一个Container可以有多个Connector，最重要的作用是将request对象和response对象进行包装。Container包含不同粒度的处理容器，包括Host，Engine，Context，Wrapper。<br>4: Executor这个接口是Lifecycle的直接子接口，同时又继承了java.util.concurrent.Executor这个内库接口。继承java.util.concurrent.Executor内库接口目的主要是Tomcat自身维护了一个线程池，后续会详细介绍Tomcat的线程池，此处先略过。<br>5: LifecycleBase：值得关注的是这是一个抽象类。此处应用了设计模式中的观察者模式，LifecycleBase和LifecycleSuporrt实现了观察者的两个类，触发LifecycleEvent事件时根据当前lifecycle对象创建事件，然后以此通知列表中的监听者。</p>
</blockquote>
<p>下一节将深度解析Server和Service的关系。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Emotion-maxfeng.github.io/Iblog/Iblog/2016/01/25/跨服务器迁移mysql数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马雪峰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/Iblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="开源技术  乐于分享">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Iblog/2016/01/25/跨服务器迁移mysql数据库/" itemprop="url">tags</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-25T10:34:38+08:00">
                2016-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>跨服务器迁移mysql数据库。</strong></p>
<p>1，把sampdb数据库从本地主机复制到远程主机121.121.121.121上的mysql服务上去。  </p>
<pre><code>mysqldump --databases 数据库名称 | mysql -h 121.121.121.121 
</code></pre><p>2，如果本地主机无法访问远程mysql服务器但能够通过登录远程主机的办法访问它，就可以通过ssh来远程调用mysql程序。  </p>
<pre><code>mysqldump --databases 数据库名称 | ssh 121.121.121.121 mysql
</code></pre><p>3，如果是通过一个慢速网络传输的话，可以通过压缩的方式传递，增快网络传输速度，–compress选项。  </p>
<pre><code>mysqldump --databases 数据库名称 | mysql --compress -h 121.121.121.121 数据库名称 
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">马雪峰</p>
              <p class="site-description motion-element" itemprop="description">燃烧陨石的博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/Iblog/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马雪峰</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/Iblog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/Iblog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/Iblog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/Iblog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/Iblog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/Iblog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/Iblog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/Iblog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/Iblog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/Iblog/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/Iblog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
